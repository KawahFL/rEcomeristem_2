#Script estimating parameters for EcoMeristem model
#Authors : Florian Larue, Gregory Beurier, Lauriane Rouan, Delphine Luquet
#-- (PAM, AGAP, BIOS, CIRAD)

###Set informations for parameter estimation###re
PPath <- "D:/Workspace/R/estim/estimlisa"
MPath <- "D:/Workspace/R/estim/estimlisa"
VPath <- "D:/Workspace/R/estim/estimlisa"
VName <- "vobs_G7moyINT_C_BFF2015.txt"
VECName <- "vobs_G7_C_BFF2015_ET_INT.txt"
ParamOfInterest <- c("Epsib", "Ict", "MGR_init", "plasto_init", "SLAp", "leaf_length_to_IN_length", "coef_MGR_PI", "slope_length_IN", "slope_LL_BL_at_PI", "density_IN1", "density_IN2")
MinValue <- c(1, 1, 1, 20, 10, 0.01, -0.5, 0.0, 0.0, 0.01, 0.1)
MaxValue <- c(10, 10, 20, 60, 120, 0.5, 0.5, 2, 0.5, 0.1, 0.5)
obsCoef <- c(1,1,1,1,1,1,1,1)
Optimizer <- "D" #(D = DE, G = RGenoud, A = Simulated Annealing, GL = lexical RGenoud (ne marche que avec RmseM 'LEC'))
RmseM <- "REC" #(RS = RSME-sum, REC = RMSE-ET, RC = RMSE-coef, RECC = RMSE-ET-coef, LEC = Lexical-ET (ne marche que avec Optimizer 'GL'))
MaxIter <- 2
SolTol <- 0.05 #/length(obsCoef)
ACluster <- FALSE  #Active la parallelisation pour les machines a minimum 4 coeurs
###End informations for parameter estimation###

#Install and load packages
list.of.packages <- c("Rcpp","recomeristem","parallel","pso", "rgenoud", "ABCoptim", "DEoptim", "truncnorm","data.table")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only=TRUE)

#Dates management
lct <- Sys.getlocale("LC_TIME"); Sys.setlocale("LC_TIME", "C")
setwd(VPath)

#Get data for simulation
meteo <- recomeristem::getMeteo_from_files(MPath)
paramInit <- recomeristem::getParameters_from_files(PPath)
vObs <- recomeristem::rcpp_get_vObs(paste(VPath,paste("/",VName, sep=""), sep=""))
obsET <- recomeristem::rcpp_get_vObs(paste(VPath,paste("/",VECName, sep=""), sep=""))
ParamList <- as.character(paramInit$Name)
paramInitTrans <- as.data.frame(matrix(ncol=length(ParamList)))
colnames(paramInitTrans) <- ParamList
paramInitTrans[1,] <- paramInit$Values
NbParam <- length(ParamOfInterest)
Bounds <- matrix(c(MinValue,MaxValue),ncol=2)

#First model run and matrix reduction
resulttmp <- recomeristem::rcpp_run_from_dataframe(paramInit, meteo)
obsRed <- recomeristem::rcpp_reduceVobs(vObs, resulttmp)
obsETRed <- recomeristem::rcpp_reduceVobs(obsET, resulttmp)
resRed <- recomeristem::rcpp_reduceResults(resulttmp, vObs)
VarList <- names(obsRed)
res <- list()

#Parallel
if(ACluster && detectCores() >= 4) {
  nbCores <- detectCores() - 2
  cl <- makeCluster(nbCores, outfile="clusterlog.txt")
  clusterEvalQ(cl, library(recomeristem,rgenoud))
  clusterExport(cl, varlist = c("meteo","vObs","obsRed", "paramInitTrans", "ParamOfInterest", "ParamList", "RmseM", "obsETRed", "obsCoef"))
}

#Functions
Optim_Ecomeristem_funct <- function(p){
  paramInitTrans[ParamOfInterest] <- p
  parameters <- data.frame(Name=ParamList, Values=unlist(paramInitTrans[1,]))
  Res_ecomeristem <- recomeristem::rcpp_run_from_dataframe(parameters,meteo)
  res <- recomeristem::rcpp_reduceResults(Res_ecomeristem, vObs)
  switch(RmseM,
         "RS" = {
           diff <- ((obsRed - res)/obsRed)^2
           return(sum(sqrt((colSums(diff, na.rm=T))/(colSums(!is.na(diff)))),na.rm=T))
         },
         "REC" = {
           diff1 <- abs(1-(data.table::between(res,obsRed-obsETRed,obsRed+obsETRed)))
           diff2 <- (abs(obsRed+obsETRed-res)/obsRed)^2
           diff3 <- (abs(obsRed-obsETRed-res)/obsRed)^2
           diff <- pmin(as.matrix(diff1*999),as.matrix(diff2),as.matrix(diff3))
           return(sum(sqrt((colSums(diff, na.rm=T))/(colSums(!is.na(diff)))),na.rm=T))
         },
         "RC" = {
           diff <- ((obsRed - res)/obsRed)^2
           rmse = sqrt((colSums(diff, na.rm=T))/(colSums(!is.na(diff))))
           return(sum(rmse*obsCoef, na.rm=T))
         },
         "RECC" = {
           diff1 <- abs(1-(data.table::between(res,obsRed-obsETRed,obsRed+obsETRed)))
           diff2 <- (abs(obsRed+obsETRed-res)/obsRed)^2
           diff3 <- (abs(obsRed-obsETRed-res)/obsRed)^2
           diff <- pmin(as.matrix(diff1*999),as.matrix(diff2),as.matrix(diff3))
           rmse = sqrt((colSums(diff, na.rm=T))/(colSums(!is.na(diff))))
           return(sum(rmse*obsCoef, na.rm=T))
         },
         "RTEST" = {
           diff = ((abs(obsRed - res) - abs(obsETRed))/obsRed)^2
           rmse = sqrt((colSums(diff, na.rm=T))/(colSums(!is.na(diff))))
           return(sum(rmse*obsCoef, na.rm=T))
         }
  )
}
simulatedAnnealing <- function(func, start_par, lower, upper, itermax = 1000, step = 0.1, printlvl = 100) {
  best_par <- current_par <- neighbor_par <- start_par
  best_value <- current_value <- neighbor_value <- func(start_par)

  message("It\tBest\tCurrent")
  message(sprintf("%i\t%.4f\t%.4f", 0L, best_value, current_value))

  for (k in 1:itermax) {
    temp <- (1 - step)^k
    neighbor_par <- rtruncnorm(length(start_par),lower, upper, current_par, 1)
    neighbor_value <- func(neighbor_par)

    if (neighbor_value < current_value || runif(1,0,1) < exp(-(neighbor_value - current_value) / temp)) {
      current_par <- neighbor_par
      current_value <- neighbor_value
    }

    if (neighbor_value < best_value) {
      best_par <- neighbor_par
      best_value <- neighbor_value
    }

    if(k%%printlvl == 0) {
      message(sprintf("%i\t%.4f\t%.4f", k, best_value, current_value))
    }
  }
  return(list(iterations = itermax, value = best_value, par = best_par))
}
optimisation <- function(Optimizer, MaxIter, SolTol, NbParam, Bounds, NbEnv, SDate, EDate) {
  switch(Optimizer,
         "D" = {
           if(ACluster && detectCores() >= 4) {
             resOptim <- DEoptim(Optim_Ecomeristem_funct, lower=Bounds[,1], upper=Bounds[,2], DEoptim.control(VTR=SolTol,itermax=MaxIter, strategy=2, cluster=cl, packages=c("recomeristem"), parVar=c("meteo","vObs","obsRed", "paramInitTrans", "ParamOfInterest", "ParamList", "RmseM", "obsETRed","obsCoef")))

           } else {
             resOptim <- DEoptim(Optim_Ecomeristem_funct, lower=Bounds[,1], upper=Bounds[,2], DEoptim.control(VTR=SolTol,itermax=MaxIter, strategy=2))
           }
           res$optimizer <- "Diffential Evolution Optimization"
           res$par <- resOptim$optim$bestmem
           res$value <- resOptim$optim$bestval
           res$iter <- resOptim$optim$iter
         },
         "G" = {
           if(ACluster && detectCores() >= 4) {
             resOptim <- genoud(Optim_Ecomeristem_funct, NbParam, max=FALSE, pop.size=100, max.generations=MaxIter, wait.generations=max(10,MaxIter/10), hard.generation.limit=TRUE, MemoryMatrix=TRUE, starting.values=NULL, Domains=Bounds, print.level=1, boundary.enforcement=2, gradient.check=FALSE, solution.tolerance=SolTol,cluster=cl)
           } else {
             resOptim <- genoud(Optim_Ecomeristem_funct, NbParam, max=FALSE, pop.size=100, max.generations=MaxIter, wait.generations=max(10,MaxIter/10), hard.generation.limit=TRUE, MemoryMatrix=TRUE, starting.values=NULL, Domains=Bounds, print.level=1, boundary.enforcement=2, gradient.check=FALSE, solution.tolerance=SolTol)
           }
           res$optimizer <- "Genetic Optimization Using Derivatives"
           TPath <- gsub("\\","/",tempdir(), fixed=TRUE)
           pop <- read.table(paste(TPath,paste("/","genoud.pro", sep=""),sep=""), comment.char='G')
           best <- pop[which.min(pop$V2),, drop = FALSE]
           res$par <- as.matrix(best[nrow(best), 3:ncol(best)])
           res$value <- as.character(best[2])
           res$iter <- nrow(best)
         },
         "GL" = {
           if(ACluster && detectCores() >= 4) {
             resOptim <- genoud(Optim_Ecomeristem_funct, NbParam, max=FALSE, pop.size=1000, max.generations=MaxIter, wait.generations=max(10,MaxIter/10), hard.generation.limit=TRUE, MemoryMatrix=TRUE, starting.values=NULL, Domains=Bounds, print.level=1, boundary.enforcement=2, gradient.check=FALSE, solution.tolerance=SolTol, lexical=TRUE, cluster=cl)
           } else {
             resOptim <- genoud(Optim_Ecomeristem_funct, NbParam, max=FALSE, pop.size=1000, max.generations=MaxIter, wait.generations=max(10,MaxIter/10), hard.generation.limit=TRUE, MemoryMatrix=TRUE, starting.values=NULL, Domains=Bounds, print.level=1, boundary.enforcement=2, gradient.check=FALSE, solution.tolerance=SolTol, lexical=TRUE)
           }
           res$optimizer <- "Genetic Optimization Using Derivatives"
           TPath <- gsub("\\","/",tempdir(), fixed=TRUE)
           pop <- read.table(paste(TPath,paste("/","genoud.pro", sep=""),sep=""), comment.char='G')
           best <- pop[which.min(pop$V2),, drop = FALSE]
           res$par <- as.matrix(best[nrow(best), 9:ncol(best)])
           res$value <- as.character(best[2:8])
           res$iter <- nrow(best)
         },
         "A" = {
           resOptim <- simulatedAnnealing(Optim_Ecomeristem_funct, start_par=Bounds[,1], lower=Bounds[,1], upper=Bounds[,2], itermax=MaxIter, step=SolTol, printlvl=max(1,MaxIter/20))
           res$optimizer <- "Simulated Annealing"
           res$par <- resOptim$par
           res$value <- resOptim$value
           res$iter <- MaxIter
         }
  )
  print("End of estimation, type res for optimisation results, type saveRes() to save output variables in csvfile, type resPlot() to see plots of observation variables, allPlot() to see plots of all computed variables and dePlot() for convergence plot (in case of optimizer = D)")
  return(list(res,resOptim))
}
resPlot <- function() {
  bestp <- as.vector(res$par)
  paramInitTrans[ParamOfInterest] <- bestp
  parameters <- data.frame(Name=ParamList, Values=unlist(paramInitTrans[1,]), row.names=NULL)
  Res_ecomeristem <- recomeristem::rcpp_run_from_dataframe(parameters,meteo)
  resRed <- recomeristem::rcpp_reduceResults(Res_ecomeristem,vObs)
  obsRed$day <- vObs$day
  plotF <- function(x) {
    if(RmseM != "RS" && RmseM != "RX") {
      plot(Res_ecomeristem[[x]], type="l", xlab="DAS", ylab=x,ylim=c(min(min(Res_ecomeristem[[x]], na.rm=T),min(obsRed[[x]]-obsETRed[[x]], na.rm=T)),max(max(Res_ecomeristem[[x]], na.rm=T),max(obsRed[[x]]+obsETRed[[x]], na.rm=T))))
      points(obsRed$day, obsRed[[x]], type="p", col="red")
      if(!is.null(obsETRed[[x]])) {
        arrows(obsRed$day,obsRed[[x]]-obsETRed[[x]],obsRed$day,obsRed[[x]]+obsETRed[[x]], code=3, length=0.02, angle = 90)
      }
      if(!is.null(obsRed[[x]])) {
        diff1 = abs(1-between(resRed[[x]],obsRed[[x]]-obsETRed[[x]],obsRed[[x]]+obsETRed[[x]]))
        diff2 = ((abs(obsRed[[x]] + obsETRed[[x]] - resRed[[x]]))/obsRed[[x]])^2
        diff3 = ((abs(obsRed[[x]] - obsETRed[[x]] - resRed[[x]]))/obsRed[[x]])^2
        return(sum(pmin(diff1*999,diff2,diff3),na.rm=T))
      } else {
        return(NULL)
      }
    } else {
      plot(Res_ecomeristem[[x]], type="l", xlab="DAS", ylab=x,ylim=c(min(Res_ecomeristem[[x]], obsRed[[x]], na.rm=T),max(Res_ecomeristem[[x]], obsRed[[x]], na.rm=T)))
      points(obsRed$day, obsRed[[x]], type="p", col="red")
      return(paste((sum((abs(obsRed[[x]]-resRed[[x]]))/(obsRed[[x]]),na.rm=T))*100,"%", sep=""))
    }
  }
  sapply(VarList, plotF)
}
dePlot <- function() {
  if(Optimizer == "D") {
    par(mfrow=c(1,1))
    plot(resOptim, type="b")
    par(mfrow=c(1,1))
    plot(resOptim, plot.type="bestvalit",type="l")
  }
}
allPlot <- function() {
  bestp <- as.vector(res$par)
  paramInitTrans[ParamOfInterest] <- bestp
  parameters <- data.frame(Name=ParamList, Values=unlist(paramInitTrans[1,]), row.names=NULL)
  Res_ecomeristem <- recomeristem::rcpp_run_from_dataframe(parameters,meteo)
  obsRed$day <- vObs$day
  plotF <- function(x) {
    plot(Res_ecomeristem[[x]], type="l", xlab="DAS", ylab=x,ylim=c(1.5*min(Res_ecomeristem[[x]], na.rm=T),1.5*max(Res_ecomeristem[[x]], na.rm=T)))
    return("Done")
  }
  sapply(names(Res_ecomeristem), plotF)
}
saveERes <- function() {
  bestp <- as.vector(res$par)
  paramInitTrans[ParamOfInterest] <- bestp
  parameters <- data.frame(Name=ParamList, Values=unlist(paramInitTrans[1,]), row.names=NULL)
  Res_ecomeristem <- recomeristem::rcpp_run_from_dataframe(parameters,meteo)
  write.csv(Res_ecomeristem, file="resultESimu.csv")
}
saveRes <- function() {
  meteo <- recomeristem::getMeteo_from_files(MPath)
  param <- recomeristem::getParameters_from_files(PPath)
  Res_ecomeristem <- recomeristem::rcpp_run_from_dataframe(paramInit, meteo)
  write.csv(Res_ecomeristem, file="resultSimu.csv")
}
recoverR <- function() {
  if(Optimizer == "G") {
    res$optimizer <<- "Genetic Optimization Using Derivatives"
    TPath <- gsub("\\","/",tempdir(), fixed=TRUE)
    pop <- read.table(paste(TPath,paste("/","genoud.pro", sep=""),sep=""), comment.char='G')
    best <- pop[which.min(pop$V2),, drop = FALSE]
    res$par <<- as.matrix(best[nrow(best), 3:ncol(best)])
    res$value <<- as.character(best[2])
  } else {
    res$optimizer <- "Genetic Optimization Using Derivatives"
    TPath <- gsub("\\","/",tempdir(), fixed=TRUE)
    pop <- read.table(paste(TPath,paste("/","genoud.pro", sep=""),sep=""), comment.char='G')
    best <- pop[which.min(pop$V2),, drop = FALSE]
    res$par <- as.matrix(best[nrow(best), 9:ncol(best)])
    res$value <- as.character(best[2:8])
    res$iter <- nrow(best)
  }
}
runModel <- function() {
  meteo <- recomeristem::getMeteo_from_files(MPath)
  param <- recomeristem::getParameters_from_files(PPath)
  assign("resultModel", recomeristem::rcpp_run_from_dataframe(paramInit, meteo), envir=.GlobalEnv)
  print("Done, check resultModel for simulation results")
}
runEModel <- function(par = res$par) {
  bestp <- as.vector(par)
  paramInitTrans[ParamOfInterest] <- bestp
  parameters <- data.frame(Name=ParamList, Values=unlist(paramInitTrans[1,]), row.names=NULL)
  assign("resultEModel", recomeristem::rcpp_run_from_dataframe(parameters,meteo), envir=.GlobalEnv)
  print("Done, check resultEModel for simulation results")
}
resEPlot <- function(par = res$par) {
  bestp <- as.vector(par)
  paramInitTrans[ParamOfInterest] <- bestp
  parameters <- data.frame(Name=ParamList, Values=unlist(paramInitTrans[1,]), row.names=NULL)
  Res_ecomeristem <- recomeristem::rcpp_run_from_dataframe(parameters,meteo)
  resRed <- recomeristem::rcpp_reduceResults(Res_ecomeristem,vObs)
  obsRed$day <- vObs$day
  plotF <- function(x) {
    if(RmseM != "RS" && RmseM != "RX") {
      plot(Res_ecomeristem[[x]], type="l", xlab="DAS", ylab=x,ylim=c(min(min(Res_ecomeristem[[x]], na.rm=T),min(obsRed[[x]]-obsETRed[[x]], na.rm=T)),max(max(Res_ecomeristem[[x]], na.rm=T),max(obsRed[[x]]+obsETRed[[x]], na.rm=T))))
      points(obsRed$day, obsRed[[x]], type="p", col="red")
      if(!is.null(obsETRed[[x]])) {
        arrows(obsRed$day,obsRed[[x]]-obsETRed[[x]],obsRed$day,obsRed[[x]]+obsETRed[[x]], code=3, length=0.02, angle = 90)
      }
      if(!is.null(obsRed[[x]])) {
        diff1 = abs(1-between(resRed[[x]],obsRed[[x]]-obsETRed[[x]],obsRed[[x]]+obsETRed[[x]]))
        diff2 = ((abs(obsRed[[x]] + obsETRed[[x]] - resRed[[x]]))/obsRed[[x]])^2
        diff3 = ((abs(obsRed[[x]] - obsETRed[[x]] - resRed[[x]]))/obsRed[[x]])^2
        return(sum(pmin(diff1*999,diff2,diff3),na.rm=T))
      } else {
        return(NULL)
      }
    } else {
      plot(Res_ecomeristem[[x]], type="l", xlab="DAS", ylab=x,ylim=c(min(Res_ecomeristem[[x]], obsRed[[x]], na.rm=T),max(Res_ecomeristem[[x]], obsRed[[x]], na.rm=T)))
      points(obsRed$day, obsRed[[x]], type="p", col="red")
      return(paste((sum((abs(obsRed[[x]]-resRed[[x]]))/(obsRed[[x]]),na.rm=T))*100,"%", sep=""))
    }

  }
  sapply(VarList, plotF)
}
savePar <- function(name = Sys.time()) {
  resPar <- matrix(as.vector(res$par), ncol=11)
  write.table(resPar, file="par.csv", sep=",", append=T, dec=".",col.names = F,row.names = name)
}
savePlots <- function(name = Sys.Date()) {
  bestp <- as.vector(res$par)
  paramInitTrans[ParamOfInterest] <- bestp
  parameters <- data.frame(Name=ParamList, Values=unlist(paramInitTrans[1,]), row.names=NULL)
  Res_ecomeristem <- recomeristem::rcpp_run_from_dataframe(parameters,meteo)
  resRed <- recomeristem::rcpp_reduceResults(Res_ecomeristem,vObs)
  obsRed$day <- vObs$day
  pdf(paste(name,".pdf",sep=""))
  plotF <- function(x) {
    if(RmseM != "RS" && RmseM != "RX") {
      plot(Res_ecomeristem[[x]], type="l", xlab="DAS", ylab=x,ylim=c(min(min(Res_ecomeristem[[x]], na.rm=T),min(obsRed[[x]]-obsETRed[[x]], na.rm=T)),max(max(Res_ecomeristem[[x]], na.rm=T),max(obsRed[[x]]+obsETRed[[x]], na.rm=T))))
      points(obsRed$day, obsRed[[x]], type="p", col="red")
      if(!is.null(obsETRed[[x]])) {
        arrows(obsRed$day,obsRed[[x]]-obsETRed[[x]],obsRed$day,obsRed[[x]]+obsETRed[[x]], code=3, length=0.02, angle = 90)
      }
      if(!is.null(obsRed[[x]])) {
        return(paste((abs(sum((abs((obsRed[[x]] - resRed[[x]]))-abs(obsETRed[[x]]))/(obsRed[[x]]), na.rm=T))*100),"%", sep=""))
      } else {
        return(NULL)
      }
    } else {
      plot(Res_ecomeristem[[x]], type="l", xlab="DAS", ylab=x,ylim=c(min(Res_ecomeristem[[x]], obsRed[[x]], na.rm=T),max(Res_ecomeristem[[x]], obsRed[[x]], na.rm=T)))
      points(obsRed$day, obsRed[[x]], type="p", col="red")
      return(paste((sum((abs(obsRed[[x]]-resRed[[x]]))/(obsRed[[x]]),na.rm=T))*100,"%", sep=""))
    }
  }
  sapply(VarList, plotF)
  dev.off()
}
saveAPlots <- function(name= Sys.Date()) {
  bestp <- as.vector(res$par)
  paramInitTrans[ParamOfInterest] <- bestp
  parameters <- data.frame(Name=ParamList, Values=unlist(paramInitTrans[1,]), row.names=NULL)
  Res_ecomeristem <- recomeristem::rcpp_run_from_dataframe(parameters,meteo)
  obsRed$day <- vObs$day
  pdf(paste("ALL",paste(name,".pdf",sep=""),sep=""))
  plotF <- function(x) {
    plot(Res_ecomeristem[[x]], type="l", xlab="DAS", ylab=x,ylim=c(1.5*min(Res_ecomeristem[[x]], na.rm=T),1.5*max(Res_ecomeristem[[x]], na.rm=T)))
    return("Done")
  }
  sapply(names(Res_ecomeristem), plotF)
  dev.off()
}


#Optimisation run
time <- system.time(resOptim <- optimisation(Optimizer, MaxIter, SolTol, NbParam, Bounds, NbEnv, SDate, EDate))
res <- resOptim[[1]]
res$time <- time
resOptim <- resOptim[[2]]
stopCluster(cl)
